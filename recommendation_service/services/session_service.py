"""
Session Tracking Service
Create and format recommendation sessions for storage
Note: Session IDs are generated by the frontend, not by this service.
"""
from datetime import datetime, timedelta
from utils.logger import get_logger

logger = get_logger(__name__)


class SessionService:
    """Service for creating and managing recommendation sessions"""
    
    def __init__(self):
        self.session_ttl_hours = 24
    
    def create_session_data(self, user_id, use_case, method, recommendations, model_version='content_based_v1.0', startup_id=None):
        """
        Format session data (without session_id - frontend generates it)
        
        Args:
            user_id: User ID or Startup ID (UUID string)
            use_case: Type of recommendation (developer_startup, startup_developer, etc.)
            method: Method used (content_based, collaborative, etc.)
            recommendations: Dict with item_ids, scores, match_reasons
            model_version: Model version string
            startup_id: Optional startup_id for reverse use cases (if provided, overrides user_id for reverse)
            
        Returns:
            dict: Formatted session data (session_id generated by frontend)
        """
        try:
            created_at = datetime.now()
            expires_at = created_at + timedelta(hours=self.session_ttl_hours)
            
            # Determine if this is a reverse use case
            reverse_use_cases = ['startup_developer', 'startup_investor']
            is_reverse = use_case in reverse_use_cases
            
            # For reverse use cases, use startup_id if provided
            if is_reverse and startup_id:
                entity_id = str(startup_id)
                entity_type = 'startup_id'
            else:
                entity_id = str(user_id)
                entity_type = 'user_id'
            
            # Format recommendations with rank
            recommendations_with_rank = []
            item_ids = recommendations.get('item_ids', [])
            scores = recommendations.get('scores', {})
            match_reasons = recommendations.get('match_reasons', {})
            
            for idx, item_id in enumerate(item_ids):
                # For reverse: item_id is user_id (developer/investor)
                # For forward: item_id is startup_id
                if is_reverse:
                    item_key = 'user_id'
                else:
                    item_key = 'startup_id'
                
                rec_data = {
                    item_key: str(item_id),
                    'rank': idx + 1,
                    'score': float(scores.get(item_id, 0.0)),
                    'match_reasons': match_reasons.get(item_id, [])
                }
                recommendations_with_rank.append(rec_data)
            
            session_data = {
                entity_type: entity_id,
                'use_case': use_case,
                'method': method,
                'model_version': model_version,
                'recommendations': recommendations_with_rank,
                'created_at': created_at.isoformat(),
                'expires_at': expires_at.isoformat()
            }
            
            # Add startup_id for reverse use cases
            if is_reverse and startup_id:
                session_data['startup_id'] = str(startup_id)
            
            logger.info(f"Formatted session data for {entity_type} {entity_id}, use_case {use_case} (session_id will be generated by frontend)")
            
            return session_data
            
        except Exception as e:
            logger.error(f"Error creating session data: {e}")
            # Return minimal session data
            reverse_use_cases = ['startup_developer', 'startup_investor']
            is_reverse = use_case in reverse_use_cases
            
            if is_reverse and startup_id:
                entity_id = str(startup_id)
                entity_type = 'startup_id'
            else:
                entity_id = str(user_id)
                entity_type = 'user_id'
            
            minimal_data = {
                entity_type: entity_id,
                'use_case': use_case,
                'method': method,
                'model_version': model_version,
                'recommendations': [],
                'created_at': datetime.now().isoformat(),
                'expires_at': (datetime.now() + timedelta(hours=self.session_ttl_hours)).isoformat()
            }
            
            if is_reverse and startup_id:
                minimal_data['startup_id'] = str(startup_id)
            
            return minimal_data
    
    def format_for_api_response(self, session_data, recommendations):
        """
        Format session data for API response (without session_id - frontend generates it)
        
        Args:
            session_data: Session data dict
            recommendations: Recommendations dict
            
        Returns:
            dict: Formatted for Flask API response
        """
        try:
            # Determine if we're returning startup_ids or user_ids
            item_ids = recommendations.get('item_ids', [])
            use_case = session_data.get('use_case', '')
            
            # For reverse use cases (startup→developer, startup→investor), return user_ids
            # For forward use cases, return startup_ids
            reverse_use_cases = ['startup_developer', 'startup_investor', 'founder_developer', 'founder_investor']
            if any(uc in use_case for uc in reverse_use_cases):
                id_key = 'user_ids'
            else:
                id_key = 'startup_ids'
            
            response = {
                'use_case': session_data['use_case'],
                'method': session_data['method'],
                'model_version': session_data['model_version'],
                id_key: [str(id) for id in item_ids],
                'scores': {str(k): float(v) for k, v in recommendations.get('scores', {}).items()},
                'match_reasons': {str(k): v for k, v in recommendations.get('match_reasons', {}).items()},
                'total': len(item_ids),
                'interaction_count': recommendations.get('interaction_count', 0),
                'created_at': session_data['created_at'],
                'expires_at': session_data['expires_at']
            }
            
            return response
            
        except Exception as e:
            logger.error(f"Error formatting API response: {e}")
            return {
                'use_case': session_data.get('use_case'),
                'method': session_data.get('method'),
                'startup_ids': [],
                'scores': {},
                'match_reasons': {},
                'total': 0,
                'interaction_count': 0,
                'created_at': session_data.get('created_at'),
                'expires_at': session_data.get('expires_at')
            }

